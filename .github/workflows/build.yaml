name: Build and Push Image

on:
  push:
    tags:
      - 'v*.*'
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ steps.version.outputs.tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      - name: Run tests
        run: |
          go test -v -race -coverprofile=coverage.out ./...

      - name: Determine version tag
        id: version
        run: |
          if [[ $GITHUB_REF == refs/tags/v* ]]; then
            TAG=${GITHUB_REF#refs/tags/}
          else
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
            COMMIT_COUNT=$(git rev-list ${LAST_TAG}..HEAD --count 2>/dev/null || echo "0")
            SHORT_SHA=$(git rev-parse --short HEAD)
            TAG="${LAST_TAG}.post${COMMIT_COUNT}-g${SHORT_SHA}"
          fi
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "Building image with tag: ${TAG}"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: ${{ github.event_name != 'pull_request' }}
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.version.outputs.tag }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          labels: ${{ steps.meta.outputs.labels }}

  integration-test:
    runs-on: ubuntu-latest
    needs: build
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build CSI driver image (amd64, local)
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          push: false
          load: true
          tags: ghcr.io/${{ github.repository }}:latest

      - name: Install kind
        run: |
          curl -Lo /usr/local/bin/kind \
            "https://kind.sigs.k8s.io/dl/v0.24.0/kind-linux-amd64"
          chmod +x /usr/local/bin/kind

      - name: Install bats
        run: |
          sudo apt-get install -y bats

      - name: Create kind cluster
        run: |
          kind create cluster \
            --name zerofs-integration \
            --config test/kind-config.yaml \
            --wait 60s

      - name: Load CSI driver image into kind
        run: |
          kind load docker-image \
            ghcr.io/${{ github.repository }}:latest \
            --name zerofs-integration

      - name: Pull zerofs server image into kind node
        run: |
          docker exec zerofs-integration-control-plane \
            ctr --namespace=k8s.io images pull \
            ghcr.io/barre/zerofs:1.0.4

      - name: Deploy CSI driver
        run: |
          kubectl apply -f deploy/install.yaml
          kubectl rollout status deployment/zerofs-csi-controller \
            -n zerofs-csi --timeout=120s
          kubectl rollout status daemonset/zerofs-csi-node \
            -n zerofs-csi --timeout=120s

      - name: Deploy MinIO
        run: |
          kubectl apply -f test/minio.yaml
          kubectl rollout status deployment/minio \
            -n zerofs-csi --timeout=120s

      - name: Create MinIO bucket
        run: |
          kubectl run minio-init \
            --image=quay.io/minio/mc:latest \
            --restart=Never \
            -n zerofs-csi \
            --command -- /bin/sh -c \
            "mc alias set local http://minio.zerofs-csi.svc.cluster.local:9000 minioadmin minioadmin123 && mc mb --ignore-existing local/zerofs-data"
          kubectl wait pod/minio-init \
            -n zerofs-csi \
            --for=condition=ready \
            --timeout=120s || true
          kubectl wait pod/minio-init \
            -n zerofs-csi \
            --for=jsonpath='{.status.phase}'=Succeeded \
            --timeout=60s

      - name: Run integration tests
        run: |
          bats test/integration-test.bats

      - name: Dump debug info on failure
        if: failure()
        run: |
          echo "=== CSI controller logs ==="
          kubectl logs -n zerofs-csi deployment/zerofs-csi-controller \
            -c zerofs-plugin --tail=100 || true
          echo "=== CSI provisioner logs ==="
          kubectl logs -n zerofs-csi deployment/zerofs-csi-controller \
            -c csi-provisioner --tail=100 || true
          echo "=== CSI node logs ==="
          kubectl logs -n zerofs-csi daemonset/zerofs-csi-node \
            -c zerofs-plugin --tail=50 || true
          echo "=== PVCs ==="
          kubectl get pvc -A || true
          echo "=== PVs ==="
          kubectl get pv || true
          echo "=== Pods ==="
          kubectl get pods -A || true
          echo "=== Deployments in zerofs-csi ==="
          kubectl get deployments -n zerofs-csi || true

      - name: Delete kind cluster
        if: always()
        run: |
          kind delete cluster --name zerofs-integration
